##### 什么是同源策略及限制
###### 概念
同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制
###### 源
源包含三部分内容：协议，域名，端口
###### IE的特殊性
IE中端口和授信范围不受同源策略限制
###### 同源策略的三种限制
1.  Cookie，localStorage和IndexDB无法获取
1.  DOM无法获得
1.  AJAX请求不能发送（ajax只能用于同源通信）
###### 前后端如何通信
- AJAX
- WebSocket
- CORS（支持跨域）

---

- XMLHTTPRequest对象的工作流程
- 兼容性处理（老版的IE不支持）
- 事件触发条件
- 事件的触发顺序
### 跨域通信的5种方式
https://juejin.im/post/5c23993de51d457b8c1f4ee1<br>
https://juejin.im/post/5a274ae9f265da430a5071eb<br>
https://segmentfault.com/a/1190000015597029<br>
1. 野路子出身却好用的方式：JSONP；
1. 官方推荐的跨域资源共享方案：CORS；
2. nodejs中间件代理跨域；
1. 使用HTML5 API：postMessage；
1. 抛弃HTTP，使用：Web Sockets；
2. 主域名相同和但子域名不同用document.domain

#### JSONP
**缺点：**
- 只能用get请求
- 不安全，返回的其实是一个脚本，可以在里面写js函数
- 没法检测请求是否成功，比如说我请求要求回调函数名是xx，后台怎么返回我都不会知道。

#### CORS
- 如果要传cookies的话，前端要带上withCredentials，后端设置allow-Credentials为true

#### Node中间件
###### 官方文档：  
https://webpack.docschina.org/configuration/dev-server/#devserver-proxy  
只需要在webpack.config.js内的devServer中配置proxy属性，一般包括4个点
1. 目标key值，只是用来替换的，一般用api表示即可
2. target属性，目标站点
3. pathReWrite属性，将目标key值替换成服务端项目路径
4. changeOrigin属性，是否跨域（这个好像没有啥作用？）  

```
devServer: {
    contentBase: path.join(__dirname, 'dist'),
    compress: true,
    port: 9000,
    proxy: {
        '/api': {
            target: 'http://localhost:8080', // 代理服务器路径
            pathRewrite: {
                '^/api': '/gc' // 重写路径
            },
            changeOrigin: true // 是否跨域
        }
    }
}
```

###### 简单请求和复杂请求
- 简单请求<br>
**满足两大条件**：<br>
1. 请求方法为：
    - get
    - post
    - head
2. 请求头为：<br>
- Accept
- Accept-Language
- Content-Language
- Last-Event-ID
- Content-Type：
    - application/x-www-form-urlencoded
    - multipart/form-data
    - text/plain
###### 分两种情况：
1. 简单请求，客户端能正常发出请求，服务端也能正常返回数据，但是浏览器不会下载这个响应的数据，在原生的ajax中，会有一个readyState的属性，我们如果是正常的启用，他会变化三次，第一次是调用send方法，第二次下载数据，第三次就是完成状态，这时候才是我们得到后台数据的时候；如果是跨域的时候，后台没有返回对应的响应头信息，xhr出错，readyState的状态直接变成完成状态，status会变成默认状态0。在谷歌浏览器的netWork中的response也可以看到返回内容，但是我们无法获取。
2. 非简单请求要经过两次请求，第一次预检请求OPTIONS，如果服务端不允许这个域通过，或者返回的请求方法中没有OPTIONS这个方法，会报403，也就是服务端已经知道客户端的请求了，但是拒绝执行；如果允许这个域通过，这时候才会执行原本的请求。
###### postMessage
window.postMessage() 是HTML5的一个接口，专注实现不同窗口不同页面的跨域通讯


## CSRF（cross-site request forgery，跨站请求伪造)
#### 概念
攻击者盗用了你的身份，以你的名义发送恶意请求
#### 原理
![image](https://pic002.cnblogs.com/img/hyddd/200904/2009040916453171.jpg)
#### 发生的两个条件
1. 登录受信任网站A，并在本地生成Cookie
2. 在不登出A的情况下，访问危险网站B
#### 防御方法
1. 服务端增加token校验，首次请求的时候按照某种规则生成token，然后存在redis中，然后再次请求的时候，在服务端的过滤器或拦截器中校验这个token。如果token在redis中已经过期了或者本来就不存在，则禁止访问
2. 服务端返回的sessionID保存在客户端的sessionStorage中，每次请求的时候也进行校验。不过这种方法有两个要注意点：
    1.  如果当前页面本身就存在xss漏洞的话，还是可能会被攻击
    2.  集群模式下，每个服务器的session都不一样，最终还是要用到redis之类的工具来配置session共享


## XSS（Cross Site Script，跨站脚本攻击）
### 可能存在位置
1. a标签的href或者img标签的src中
2. 拼接html的时候，比如说富文本框中的内容

### 防御
1. 限制输入框的长度
2. 将dom结构和数据分开，明确告诉浏览器这是html还是文本
3. 使用innerHTML，document.write时要注意，如果使用vue的话，v-html也会拼接html造成漏洞
4. 可以使用一些xss扫描工具验证然后再针对处理

## HTTP状态码
- 400，客户端请求的语法错误，服务端无法理解。比如说客户端是发的POST请求，服务端却用@RequestParameter，也就是从Header里面获取参数。或者是用get方法的时候，在请求体发送了参数
- 403，服务端理解了客户端的请求，但是拒绝执行。比如说跨域请求的时候，客户端的域不在服务端的白名单中，或者服务端不允许某个类型的方法跨域。
- 404，找不到这个资源。
- 405，客户端请求的方法被禁止。比如说服务端设置了只允许GET方法，客户端用POST方法来调。
- 415，媒体类型错误。比如说我后端RequestBody要求请求的参数是json格式，但是客户端用了不是application/json这种content-type
- 406，Not Acceptable，request的Accept和response的Content-Type不匹配？
###### readyState
- 0，open未打开
- 1，open方法被调用
- 2，send方法被调用
- 3，下载响应体中，如果这时候是获取responseText的话，已经有部分响应体了
- 4，完成下载。
- 所以完成执行的方法要放在status=200和readyState=4的判断中